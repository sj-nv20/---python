#1085***
# 소리가 컴퓨터에 저장될 때에는 디지털 데이터화 되어 저장된다.
# 마이크를 통해 1초에 적게는 수십 번, 많게는 수만 번 소리의 강약을 체크해
# 그 값을 정수값으로 바꾸고, 그 값을 저장해 소리를 파일로 저장할 수 있다.
# 값을 저장할 때에는 비트를 사용하는 정도에 따라 세세한 녹음 정도를 결정할 수 있고,
# 좌우(스테레오) 채널로 저장하면 2배… 5.1채널이면 6배의 저장공간이 필요하고,
# 녹음 시간이 길면 그 만큼 더 많은 저장공간이 필요하다.
# 1초 동안 마이크로 소리강약을 체크하는 수를 h (헤르쯔, Hz 는 1초에 몇 번? 체크하는가를 의미한다.)
# 한 번 체크한 결과를 저장하는 비트 b (2비트를 사용하면 0 또는 1 두 가지, 16비트를 사용하면 65536가지..)
# 좌우 등 소리를 저장할 트랙 개수인 채널 c (모노는 1개, 스테레오는 2개의 트랙으로 저장함을 의미한다.)
# 녹음할 시간 s가 주어질 때, 필요한 저장 용량을 계산하는 프로그램을 작성해보자.
h,b,c,s = map(int,input().split())
print('%.1f MB' %(h*b*c*s/8/1024/1024))

#1086
# 이미지가 컴퓨터에 저장될 때에도 디지털 데이터화 되어 저장된다.
# 가장 기본적인 방법으로는 그림을 구성하는 한 점(pixel, 픽셀)의 색상을
# 빨강(r), 초록(g), 파랑(b)의 3가지의 빛의 세기 값으로 따로 변환하여 저장하는 것인데,
# 예를 들어 r, g, b 각 색에 대해서 8비트(0~255, 256가지 가능)씩을 사용한다고 하면,
# 한 점의 색상은 3가지 r, g, b의 8비트+8비트+8비트로 총 24비트로 표현해서
# 총 2^24 가지의 서로 다른 빛의 색깔을 사용할 수 있는 것이다.
# 그렇게 저장하는 점을 모아 하나의 큰 이미지를 저장할 수 있게 되는데,
# 1024 * 768 사이즈에 각 점에 대해 24비트로 저장하면 그 이미지를 저장하기 위한
# 저장 용량을 계산할 수 있다.
# 이렇게 이미지의 원래(raw) 데이터를 압축하지 않고 그대로 저장하는 대표적인 이미지 파일이
# *.bmp 파일이며, 비트로 그림을 구성한다고 하여 비트맵 방식 또는 래스터 방식이라고 한다.
# 이미지의 가로 해상도 w, 세로 해상도 h, 한 픽셀을 저장하기 위한 비트 b 가 주어질 때,
# 압축하지 않고 저장하기 위해 필요한 저장 용량을 계산하는 프로그램을 작성해 보자.
w,h,b = map(int,input().split())
print("%.2f MB" % (w*h*b/8/1024/1024))

#1087
# 1, 2, 3 ... 을 순서대로 계속 더해나갈 때,
# 그 합이 입력한 정수보다 작을 동안만 계속 더하는 프로그램을 작성해보자.
a = int(input())
sum = 0
for x in range (1,a+1):
    sum += x
    if sum >= a:
        break;
print(sum)

#1088
# 1부터 입력한 정수까지 1씩 증가시켜 출력하는 프로그램을 작성하되,
# 3의 배수인 경우는 출력하지 않도록 만들어보자.
a = int(input())
for x in range (1, a+1) :
    if x%3 == 0:
        continue;
    else :
        print(x)

#1089
# 시작 값(a), 등차(d), 몇 번째인지를 나타내는 정수(n)가 입력될 때
# n번째 수를 출력하는 프로그램을 만들어보자.
a,d,n = map(int,input().split())
print(a + (n-1) * d)

#1090
# 시작 값(a), 등비(r), 몇 번째인지를 나타내는 정수(n)가 입력될 때
# n번째 수를 출력하는 프로그램을 만들어보자.
a,r,n = map(int,input().split())
print(a * r**(n-1))